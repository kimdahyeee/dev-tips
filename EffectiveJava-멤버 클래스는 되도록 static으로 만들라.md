> 문득, 당연스럽게 사용하던 정적 멤버 클래스를 사용하는 이유가 궁금해졌다.

### 멤버 클래스는 되도록 static으로 만들라

---

```java
public class A {
    // 나는 왜 당연스럽게 static 을 쓰고 있는가....
    public static class B {
        
    }
}
```


#### 🙋‍♀ 비정적 멤버 클래스와 정적 멤버 클래스의 **공통점**은 ?

- 다른 클래스 안에 선언되는 클래스(즉, `중첩 클래스`)

#### 🙋‍♀ 정적 멤버 클래스와 비정적 멤버 클래스 **차이점**은 ?

☝ `static`이 붙어 있고 안붙어 있고의 차이다.

✌ `정적 멤버 클래스`와 다르게 `비정적 멤버 클래스`는 `바깥 클래스`의 `인스턴스`와 암묵적으로 연결된다.

```java
public class A {
    private Integer a;
    
    public static class B {
        public void b() {
            // a 호출 불가능
        }
    }
    
    public class C {
        public void c() {
            // a 호출 가능 !
        }
    }
}
```

> 따라서, 개념상 `중첩 클래스`의 `인스턴스`가 `바깥 인스턴스`와 **독립적**으로 존재할 수 있다면 `정적 멤버 클래스`로 만들어야 한다.

#### 🙋‍♀ 더더욱 `정적 클래스`를 사용해야 하는 이유는 ?

☝ '`비정적 멤버 클래스`는 `바깥 클래스`의 `인스턴스`와 암묵적으로 연결된다'는 말은 해당 참조 저장을 하기 위해 시간, 공간을 소비하게 된다는 말이다.

✌ 가비지 컬렉션이 `바깥 클래스`의 `인스턴스`를 수거해가지 못하는 문제점이 발생할 수 있다. 메모리 누수로 이어질 수 있음

#### 🙋‍♀ 가비지 컬렉션 메모리 누수에 대해 조금 더 자세히 말하자면 ?
- 가비지 컬렉터는 **다 쓴** 객체를 수거해간다.
- 하지만, 객체 참조가 살아있다면, 참조하는 모든 객체를 회수하지 못하게 된다.
  
  `stack`을 예로 들어보자. `stack`에 메모리를 `push` 했다가 `pop` 하는 로직이 있다고 정의했을때,
    `pop`된 해당 인덱스에 null 처리를 안해준다면 참조 해제 처리를 하지 않은 것이다. (참조가 남아 있어 가비지 컬렉터가 회수하지 못하게 됨)

#### 갑자기 분위기 결론
멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 **무조건** static을 부여 정적 멤버 클래스로 만들자. 

😮 참고: effective java 3/e, item 24 & item 7